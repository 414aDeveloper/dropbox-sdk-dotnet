// <auto-generated>
// Auto-generated by BabelAPI, do not modify.
// </auto-generated>

namespace Dropbox.Api.Files.Routes
{
    using sys = System;
    using io = System.IO;
    using col = System.Collections.Generic;
    using t = System.Threading.Tasks;
    using enc = Dropbox.Api.Babel;

    /// <summary>
    /// <para>The routes for the <see cref="N:Dropbox.Api.Files"/> namespace</para>
    /// </summary>
    public class FilesRoutes
    {
        /// <summary>
        /// <para>Initializes a new instance of the <see cref="FilesRoutes" /> class.</para>
        /// </summary>
        /// <param name="transport">The transport to use</param>
        internal FilesRoutes(enc.ITransport transport)
        {
            this.Transport = transport;
        }

        /// <summary>
        /// <para>Gets the transport used for these routes</para>
        /// </summary>
        internal enc.ITransport Transport { get; private set; }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{GetMetadataError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<Metadata> GetMetadataAsync(GetMetadataArg getMetadataArg)
        {
            return this.Transport.SendRpcRequestAsync<GetMetadataArg, Metadata, GetMetadataError>(getMetadataArg, "api", "/files/get_metadata");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(GetMetadataArg getMetadataArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetMetadataAsync(getMetadataArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// </summary>
        /// <param name="path">The path of the file or folder on Dropbox. Must not be the
        /// root.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{GetMetadataError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<Metadata> GetMetadataAsync(string path)
        {
            var getMetadataArg = new GetMetadataArg(path);

            return this.GetMetadataAsync(getMetadataArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="path">The path of the file or folder on Dropbox. Must not be the
        /// root.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(string path,
                                                 sys.AsyncCallback callback,
                                                 object callbackState = null)
        {
            var getMetadataArg = new GetMetadataArg(path);

            return this.BeginGetMetadata(getMetadataArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get metadata route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{GetMetadataError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public Metadata EndGetMetadata(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the contents of a folder.</para>
        /// <para>NOTE: We're definitely going to streamline this interface.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderResult, ListFolderError>(listFolderArg, "api", "/files/list_folder");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the contents of a folder.</para>
        /// <para>NOTE: We're definitely going to streamline this interface.</para>
        /// </summary>
        /// <param name="path">The path to the folder you want to see the contents of. May be
        /// the root (i.e. empty).</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(string path)
        {
            var listFolderArg = new ListFolderArg(path);

            return this.ListFolderAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="path">The path to the folder you want to see the contents of. May be
        /// the root (i.e. empty).</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(string path,
                                                sys.AsyncCallback callback,
                                                object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path);

            return this.BeginListFolder(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderResult EndListFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder.</para>
        /// <para>NOTE: We're definitely going to streamline this interface.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderContinueError}">Thrown if there
        /// is an error processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(ListFolderContinueArg listFolderContinueArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderContinueArg, ListFolderResult, ListFolderContinueError>(listFolderContinueArg, "api", "/files/list_folder/continue");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(ListFolderContinueArg listFolderContinueArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderContinueAsync(listFolderContinueArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder.</para>
        /// <para>NOTE: We're definitely going to streamline this interface.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderContinueError}">Thrown if there
        /// is an error processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderContinueAsync(string cursor)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.ListFolderContinueAsync(listFolderContinueArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="cursor">The cursor returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" /> or <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderContinueAsync" />.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(string cursor,
                                                        sys.AsyncCallback callback,
                                                        object callbackState = null)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.BeginListFolderContinue(listFolderContinueArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder continue route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderContinueError}">Thrown if there
        /// is an error processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public ListFolderResult EndListFolderContinue(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Download a file from a user's Dropbox.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{DownloadError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> DownloadAsync(DownloadArg downloadArg)
        {
            return this.Transport.SendDownloadRequestAsync<DownloadArg, FileMetadata, DownloadError>(downloadArg, "content", "/files/download");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(DownloadArg downloadArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DownloadAsync(downloadArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Download a file from a user's Dropbox.</para>
        /// </summary>
        /// <param name="path">The path of the file to download.</param>
        /// <param name="rev">Optional revision, taken from the corresponding <see
        /// cref="Metadata" /> field.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{DownloadError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> DownloadAsync(string path,
                                                                         string rev = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.DownloadAsync(downloadArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="path">The path of the file to download.</param>
        /// <param name="rev">Optional revision, taken from the corresponding <see
        /// cref="Metadata" /> field.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(string path,
                                              string rev = null,
                                              sys.AsyncCallback callback = null,
                                              object callbackState = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.BeginDownload(downloadArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the download route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{DownloadError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndDownload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Start a new upload session. This is used to upload a single file with
        /// multiple calls.</para>
        /// </summary>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionStartResult> UploadSessionStartAsync(io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<enc.Empty, UploadSessionStartResult, enc.Empty>(enc.Empty.Instance, body, "content", "/files/upload_session/start");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session start route.</para>
        /// </summary>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionStart(io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionStartAsync(body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session start route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public UploadSessionStartResult EndUploadSessionStart(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionStartResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionLookupError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendAsync(UploadSessionCursor uploadSessionCursor, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionCursor, enc.Empty, UploadSessionLookupError>(uploadSessionCursor, body, "content", "/files/upload_session/append");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppend(UploadSessionCursor uploadSessionCursor, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionAppendAsync(uploadSessionCursor, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// </summary>
        /// <param name="sessionId">The upload session ID (returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />).</param>
        /// <param name="offset">The amount of data that has been uploaded so far. We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionLookupError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendAsync(string sessionId,
                                               ulong offset,
                                               io.Stream body)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.UploadSessionAppendAsync(uploadSessionCursor, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="sessionId">The upload session ID (returned by <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.UploadSessionStartAsync" />).</param>
        /// <param name="offset">The amount of data that has been uploaded so far. We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppend(string sessionId,
                                                         ulong offset,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.BeginUploadSessionAppend(uploadSessionCursor, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session append route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionLookupError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public void EndUploadSessionAppend(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionFinishError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadata> UploadSessionFinishAsync(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionFinishArg, FileMetadata, UploadSessionFinishError>(uploadSessionFinishArg, body, "content", "/files/upload_session/finish");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishAsync(uploadSessionFinishArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="commit">Contains the path and other optional modifiers for the
        /// commit.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionFinishError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadata> UploadSessionFinishAsync(UploadSessionCursor cursor,
                                                             CommitInfo commit,
                                                             io.Stream body)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.UploadSessionFinishAsync(uploadSessionFinishArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="cursor">Contains the upload session ID and the offset.</param>
        /// <param name="commit">Contains the path and other optional modifiers for the
        /// commit.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionCursor cursor,
                                                         CommitInfo commit,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.BeginUploadSessionFinish(uploadSessionFinishArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionFinishError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public FileMetadata EndUploadSessionFinish(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadata> UploadAsync(CommitInfo commitInfo, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<CommitInfo, FileMetadata, UploadError>(commitInfo, body, "content", "/files/upload");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(CommitInfo commitInfo, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadAsync(commitInfo, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadata> UploadAsync(string path,
                                                WriteMode mode = null,
                                                bool autorename = false,
                                                sys.DateTime? clientModified = null,
                                                bool mute = false,
                                                io.Stream body = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute);

            return this.UploadAsync(commitInfo, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">Selects what to do if the file already exists.</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp. Dropbox automatically records the time at which
        /// the file was written to the Dropbox servers. It can also record an additional
        /// timestamp, provided by Dropbox desktop clients, mobile clients, and API apps of
        /// when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software. If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(string path,
                                            WriteMode mode = null,
                                            bool autorename = false,
                                            sys.DateTime? clientModified = null,
                                            bool mute = false,
                                            io.Stream body = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute);

            return this.BeginUpload(commitInfo, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public FileMetadata EndUpload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// </summary>
        /// <param name="searchQuery">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{SearchError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResults> SearchAsync(SearchQuery searchQuery)
        {
            return this.Transport.SendRpcRequestAsync<SearchQuery, SearchResults, SearchError>(searchQuery, "api", "/files/search");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="searchQuery">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(SearchQuery searchQuery, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SearchAsync(searchQuery);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search. Should probably be a
        /// folder. May be the root (i.e. empty).</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The search mode (filename, filename_and_content, or
        /// deleted_filename).</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{SearchError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResults> SearchAsync(string path,
                                                 string query,
                                                 ulong start = 0,
                                                 ulong maxResults = 100,
                                                 SearchMode mode = null)
        {
            var searchQuery = new SearchQuery(path,
                                              query,
                                              start,
                                              maxResults,
                                              mode);

            return this.SearchAsync(searchQuery);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search. Should probably be a
        /// folder. May be the root (i.e. empty).</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The search mode (filename, filename_and_content, or
        /// deleted_filename).</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(string path,
                                            string query,
                                            ulong start = 0,
                                            ulong maxResults = 100,
                                            SearchMode mode = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var searchQuery = new SearchQuery(path,
                                              query,
                                              start,
                                              maxResults,
                                              mode);

            return this.BeginSearch(searchQuery, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the search route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{SearchError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public SearchResults EndSearch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SearchResults>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// <para>No file or folder may exist at the path. The parent folder will be created if
        /// it does not already exist (and so on). If the parent exists it must be a folder
        /// (and the same for any ancestor). If an ancestor is a shared folder it must have
        /// write access.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{PathError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PathError"/>.</exception>
        public t.Task<FolderMetadata> CreateFolderAsync(CreateFolderArg createFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<CreateFolderArg, FolderMetadata, PathError>(createFolderArg, "api", "/files/create_folder");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="createFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolder(CreateFolderArg createFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CreateFolderAsync(createFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a folder at a given path.</para>
        /// <para>No file or folder may exist at the path. The parent folder will be created if
        /// it does not already exist (and so on). If the parent exists it must be a folder
        /// (and the same for any ancestor). If an ancestor is a shared folder it must have
        /// write access.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{PathError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PathError"/>.</exception>
        public t.Task<FolderMetadata> CreateFolderAsync(string path)
        {
            var createFolderArg = new CreateFolderArg(path);

            return this.CreateFolderAsync(createFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the create folder route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to create.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCreateFolder(string path,
                                                  sys.AsyncCallback callback,
                                                  object callbackState = null)
        {
            var createFolderArg = new CreateFolderArg(path);

            return this.BeginCreateFolder(createFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the create folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{PathError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PathError"/>.</exception>
        public FolderMetadata EndCreateFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FolderMetadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder all its contents will be deleted too.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{PathError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PathError"/>.</exception>
        public t.Task<Metadata> DeleteAsync(DeleteArg deleteArg)
        {
            return this.Transport.SendRpcRequestAsync<DeleteArg, Metadata, PathError>(deleteArg, "api", "/files/delete");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="deleteArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDelete(DeleteArg deleteArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DeleteAsync(deleteArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Delete the file or folder at a given path.</para>
        /// <para>If the path is a folder all its contents will be deleted too.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{PathError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PathError"/>.</exception>
        public t.Task<Metadata> DeleteAsync(string path)
        {
            var deleteArg = new DeleteArg(path);

            return this.DeleteAsync(deleteArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the delete route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to delete.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDelete(string path,
                                            sys.AsyncCallback callback,
                                            object callbackState = null)
        {
            var deleteArg = new DeleteArg(path);

            return this.BeginDelete(deleteArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the delete route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{PathError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="PathError"/>.</exception>
        public Metadata EndDelete(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Copy a file or folder to a different destination in the user's
        /// Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied. The
        /// destination path must not yet exist.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{RelocationError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> CopyAsync(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, Metadata, RelocationError>(relocationArg, "api", "/files/copy");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopy(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.CopyAsync(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Copy a file or folder to a different destination in the user's
        /// Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be copied. The
        /// destination path must not yet exist.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{RelocationError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> CopyAsync(string fromPath,
                                          string toPath)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.CopyAsync(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the copy route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginCopy(string fromPath,
                                          string toPath,
                                          sys.AsyncCallback callback,
                                          object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.BeginCopy(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the copy route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{RelocationError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public Metadata EndCopy(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Move a file or folder to a different destination in the user's
        /// Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved. The
        /// destination path must not yet exist.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{RelocationError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> MoveAsync(RelocationArg relocationArg)
        {
            return this.Transport.SendRpcRequestAsync<RelocationArg, Metadata, RelocationError>(relocationArg, "api", "/files/move");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="relocationArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMove(RelocationArg relocationArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.MoveAsync(relocationArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Move a file or folder to a different destination in the user's
        /// Dropbox.</para>
        /// <para>If the source path is a folder all its contents will be moved. The
        /// destination path must not yet exist.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{RelocationError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public t.Task<Metadata> MoveAsync(string fromPath,
                                          string toPath)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.MoveAsync(relocationArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the move route.</para>
        /// </summary>
        /// <param name="fromPath">Path in the user's Dropbox to be copied or moved.</param>
        /// <param name="toPath">Path in the user's Dropbox that is the destination.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginMove(string fromPath,
                                          string toPath,
                                          sys.AsyncCallback callback,
                                          object callbackState = null)
        {
            var relocationArg = new RelocationArg(fromPath,
                                                  toPath);

            return this.BeginMove(relocationArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the move route to complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{RelocationError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="RelocationError"/>.</exception>
        public Metadata EndMove(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<Metadata>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// </summary>
        /// <param name="thumbnailArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ThumbnailError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetThumbnailAsync(ThumbnailArg thumbnailArg)
        {
            return this.Transport.SendDownloadRequestAsync<ThumbnailArg, FileMetadata, ThumbnailError>(thumbnailArg, "content", "/files/get_thumbnail");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="thumbnailArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnail(ThumbnailArg thumbnailArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetThumbnailAsync(thumbnailArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Get a thumbnail for an image.</para>
        /// </summary>
        /// <param name="path">The path to the image file you want to thumbnail.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image (default s).</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ThumbnailError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadata>> GetThumbnailAsync(string path,
                                                                             ThumbnailFormat format = null,
                                                                             ThumbnailSize size = null)
        {
            var thumbnailArg = new ThumbnailArg(path,
                                                format,
                                                size);

            return this.GetThumbnailAsync(thumbnailArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get thumbnail route.</para>
        /// </summary>
        /// <param name="path">The path to the image file you want to thumbnail.</param>
        /// <param name="format">The format for the thumbnail image, jpeg (default) or png. For
        /// images that are photos, jpeg should be preferred, while png is  better for
        /// screenshots and digital arts.</param>
        /// <param name="size">The size for the thumbnail image (default s).</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetThumbnail(string path,
                                                  ThumbnailFormat format = null,
                                                  ThumbnailSize size = null,
                                                  sys.AsyncCallback callback = null,
                                                  object callbackState = null)
        {
            var thumbnailArg = new ThumbnailArg(path,
                                                format,
                                                size);

            return this.BeginGetThumbnail(thumbnailArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get thumbnail route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{ThumbnailError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ThumbnailError"/>.</exception>
        public enc.IDownloadResponse<FileMetadata> EndGetThumbnail(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadata>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }
    }
}
