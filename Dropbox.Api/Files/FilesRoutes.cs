// <auto-generated>
// Auto-generated by BabelAPI, do not modify.
// </auto-generated>

namespace Dropbox.Api.Files.Routes
{
    using sys = System;
    using io = System.IO;
    using col = System.Collections.Generic;
    using t = System.Threading.Tasks;
    using enc = Dropbox.Api.Babel;

    /// <summary>
    /// <para>The routes for the <see cref="N:Dropbox.Api.Files"/> namespace</para>
    /// </summary>
    public class FilesRoutes
    {
        /// <summary>
        /// <para>Initializes a new instance of the FilesRoutes class</para>
        /// </summary>
        /// <param name="transport">The transport to use</param>
        internal FilesRoutes(enc.ITransport transport)
        {
            this.Transport = transport;
        }

        /// <summary>
        /// <para>Gets the transport used for these routes</para>
        /// </summary>
        internal enc.ITransport Transport { get; private set; }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{GetMetadataError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<MetadataWithName> GetMetadataAsync(GetMetadataArg getMetadataArg)
        {
            return this.Transport.SendRpcRequestAsync<GetMetadataArg, MetadataWithName, GetMetadataError>(getMetadataArg, "api", "/files/get_metadata");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="getMetadataArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(GetMetadataArg getMetadataArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.GetMetadataAsync(getMetadataArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the metadata for a file or folder.</para>
        /// </summary>
        /// <param name="path">The path</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{GetMetadataError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public t.Task<MetadataWithName> GetMetadataAsync(string path)
        {
            var getMetadataArg = new GetMetadataArg(path);

            return this.GetMetadataAsync(getMetadataArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the get metadata route.</para>
        /// </summary>
        /// <param name="path">The path</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginGetMetadata(string path,
                                                 sys.AsyncCallback callback,
                                                 object callbackState = null)
        {
            var getMetadataArg = new GetMetadataArg(path);

            return this.BeginGetMetadata(getMetadataArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the get metadata route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{GetMetadataError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="GetMetadataError"/>.</exception>
        public MetadataWithName EndGetMetadata(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<MetadataWithName>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Returns the contents of a folder.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(ListFolderArg listFolderArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderArg, ListFolderResult, ListFolderError>(listFolderArg, "api", "/files/list_folder");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="listFolderArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(ListFolderArg listFolderArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderAsync(listFolderArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Returns the contents of a folder.</para>
        /// </summary>
        /// <param name="path">The path</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public t.Task<ListFolderResult> ListFolderAsync(string path)
        {
            var listFolderArg = new ListFolderArg(path);

            return this.ListFolderAsync(listFolderArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder route.</para>
        /// </summary>
        /// <param name="path">The path</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolder(string path,
                                                sys.AsyncCallback callback,
                                                object callbackState = null)
        {
            var listFolderArg = new ListFolderArg(path);

            return this.BeginListFolder(listFolderArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="ListFolderError"/>.</exception>
        public ListFolderResult EndListFolder(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderContinueError}">Thrown if there
        /// is an error processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderContinueResult> ListFolderContinueAsync(ListFolderContinueArg listFolderContinueArg)
        {
            return this.Transport.SendRpcRequestAsync<ListFolderContinueArg, ListFolderContinueResult, ListFolderContinueError>(listFolderContinueArg, "api", "/files/list_folder/continue");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="listFolderContinueArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(ListFolderContinueArg listFolderContinueArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.ListFolderContinueAsync(listFolderContinueArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Once a cursor has been retrieved from <see
        /// cref="Dropbox.Api.Files.Routes.FilesRoutes.ListFolderAsync" />, use this to
        /// paginate through all files and retrieve updates to the folder.</para>
        /// </summary>
        /// <param name="cursor">The cursor</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderContinueError}">Thrown if there
        /// is an error processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public t.Task<ListFolderContinueResult> ListFolderContinueAsync(string cursor)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.ListFolderContinueAsync(listFolderContinueArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the list folder continue route.</para>
        /// </summary>
        /// <param name="cursor">The cursor</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginListFolderContinue(string cursor,
                                                        sys.AsyncCallback callback,
                                                        object callbackState = null)
        {
            var listFolderContinueArg = new ListFolderContinueArg(cursor);

            return this.BeginListFolderContinue(listFolderContinueArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the list folder continue route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{ListFolderContinueError}">Thrown if there
        /// is an error processing the request; This will contain a <see
        /// cref="ListFolderContinueError"/>.</exception>
        public ListFolderContinueResult EndListFolderContinue(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<ListFolderContinueResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Download a file in a user's Dropbox.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{DownloadError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadataWithName>> DownloadAsync(DownloadArg downloadArg)
        {
            return this.Transport.SendDownloadRequestAsync<DownloadArg, FileMetadataWithName, DownloadError>(downloadArg, "content", "/files/download");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="downloadArg">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(DownloadArg downloadArg, sys.AsyncCallback callback, object state = null)
        {
            var task = this.DownloadAsync(downloadArg);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Download a file in a user's Dropbox.</para>
        /// </summary>
        /// <param name="path">The path</param>
        /// <param name="rev">The rev</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{DownloadError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public t.Task<enc.IDownloadResponse<FileMetadataWithName>> DownloadAsync(string path,
                                                                                 string rev = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.DownloadAsync(downloadArg);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the download route.</para>
        /// </summary>
        /// <param name="path">The path</param>
        /// <param name="rev">The rev</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginDownload(string path,
                                              string rev = null,
                                              sys.AsyncCallback callback = null,
                                              object callbackState = null)
        {
            var downloadArg = new DownloadArg(path,
                                              rev);

            return this.BeginDownload(downloadArg, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the download route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{DownloadError}">Thrown if there is an
        /// error processing the request; This will contain a <see
        /// cref="DownloadError"/>.</exception>
        public enc.IDownloadResponse<FileMetadataWithName> EndDownload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<enc.IDownloadResponse<FileMetadataWithName>>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Start a new upload session, which is used to upload a single file with
        /// multiple calls.</para>
        /// </summary>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        public t.Task<UploadSessionStartResult> UploadSessionStartAsync(io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<enc.Empty, UploadSessionStartResult, enc.Empty>(enc.Empty.Instance, body, "content", "/files/upload_session/start");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session start route.</para>
        /// </summary>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionStart(io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionStartAsync(body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session start route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        public UploadSessionStartResult EndUploadSessionStart(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<UploadSessionStartResult>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionLookupError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendAsync(UploadSessionCursor uploadSessionCursor, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionCursor, enc.Empty, UploadSessionLookupError>(uploadSessionCursor, body, "content", "/files/upload_session/append");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="uploadSessionCursor">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppend(UploadSessionCursor uploadSessionCursor, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionAppendAsync(uploadSessionCursor, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Append more data to an upload session.</para>
        /// </summary>
        /// <param name="sessionId">The session id</param>
        /// <param name="offset">The amount of data that has been uploaded so far.  We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionLookupError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public t.Task UploadSessionAppendAsync(string sessionId,
                                               ulong offset,
                                               io.Stream body)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.UploadSessionAppendAsync(uploadSessionCursor, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session append route.</para>
        /// </summary>
        /// <param name="sessionId">The session id</param>
        /// <param name="offset">The amount of data that has been uploaded so far.  We use this
        /// to make sure upload data isn't lost or duplicated in the event of a network
        /// error.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionAppend(string sessionId,
                                                         ulong offset,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionCursor = new UploadSessionCursor(sessionId,
                                                              offset);

            return this.BeginUploadSessionAppend(uploadSessionCursor, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session append route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionLookupError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionLookupError"/>.</exception>
        public void EndUploadSessionAppend(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionFinishError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadataWithName> UploadSessionFinishAsync(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<UploadSessionFinishArg, FileMetadataWithName, UploadSessionFinishError>(uploadSessionFinishArg, body, "content", "/files/upload_session/finish");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="uploadSessionFinishArg">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionFinishArg uploadSessionFinishArg, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadSessionFinishAsync(uploadSessionFinishArg, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Finish an upload session and save the uploaded data to the given file
        /// path.</para>
        /// </summary>
        /// <param name="cursor">The cursor</param>
        /// <param name="commit">The commit</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionFinishError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public t.Task<FileMetadataWithName> UploadSessionFinishAsync(UploadSessionCursor cursor,
                                                                     CommitInfo commit,
                                                                     io.Stream body)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.UploadSessionFinishAsync(uploadSessionFinishArg, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload session finish route.</para>
        /// </summary>
        /// <param name="cursor">The cursor</param>
        /// <param name="commit">The commit</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUploadSessionFinish(UploadSessionCursor cursor,
                                                         CommitInfo commit,
                                                         io.Stream body,
                                                         sys.AsyncCallback callback,
                                                         object callbackState = null)
        {
            var uploadSessionFinishArg = new UploadSessionFinishArg(cursor,
                                                                    commit);

            return this.BeginUploadSessionFinish(uploadSessionFinishArg, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload session finish route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadSessionFinishError}">Thrown if
        /// there is an error processing the request; This will contain a <see
        /// cref="UploadSessionFinishError"/>.</exception>
        public FileMetadataWithName EndUploadSessionFinish(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadataWithName>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters</param>
        /// <param name="body">The content to upload.</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadataWithName> UploadAsync(CommitInfo commitInfo, io.Stream body)
        {
            return this.Transport.SendUploadRequestAsync<CommitInfo, FileMetadataWithName, UploadError>(commitInfo, body, "content", "/files/upload");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="commitInfo">The request parameters.</param>
        /// <param name="body">The content to upload.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(CommitInfo commitInfo, io.Stream body, sys.AsyncCallback callback, object state = null)
        {
            var task = this.UploadAsync(commitInfo, body);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Create a new file with the contents provided in the request.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">The mode</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp.  Dropbox automatically records the time at
        /// which the file was written to the Dropbox servers.  It can also record an
        /// additional timestamp, provided by Dropbox desktop clients, mobile clients, and API
        /// apps of when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software.  If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="body">The document to upload</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public t.Task<FileMetadataWithName> UploadAsync(string path,
                                                        WriteMode mode = null,
                                                        bool autorename = false,
                                                        sys.DateTime? clientModified = null,
                                                        bool mute = false,
                                                        io.Stream body = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute);

            return this.UploadAsync(commitInfo, body);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the upload route.</para>
        /// </summary>
        /// <param name="path">Path in the user's Dropbox to save the file.</param>
        /// <param name="mode">The mode</param>
        /// <param name="autorename">If there's a conflict, as determined by <paramref
        /// name="mode" />, have the Dropbox server try to autorename the file to avoid
        /// conflict.</param>
        /// <param name="clientModified">The value to store as the <paramref
        /// name="clientModified" /> timestamp.  Dropbox automatically records the time at
        /// which the file was written to the Dropbox servers.  It can also record an
        /// additional timestamp, provided by Dropbox desktop clients, mobile clients, and API
        /// apps of when the file was actually created or modified.</param>
        /// <param name="mute">Normally, users are made aware of any file modifications in
        /// their Dropbox account via notifications in the client software.  If <c>true</c>,
        /// this tells the clients that this modification shouldn't result in a user
        /// notification.</param>
        /// <param name="body">The document to upload</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginUpload(string path,
                                            WriteMode mode = null,
                                            bool autorename = false,
                                            sys.DateTime? clientModified = null,
                                            bool mute = false,
                                            io.Stream body = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var commitInfo = new CommitInfo(path,
                                            mode,
                                            autorename,
                                            clientModified,
                                            mute);

            return this.BeginUpload(commitInfo, body, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the upload route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{UploadError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="UploadError"/>.</exception>
        public FileMetadataWithName EndUpload(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<FileMetadataWithName>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// </summary>
        /// <param name="searchQuery">The request parameters</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{SearchError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResults> SearchAsync(SearchQuery searchQuery)
        {
            return this.Transport.SendRpcRequestAsync<SearchQuery, SearchResults, SearchError>(searchQuery, "api", "/files/search");
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="searchQuery">The request parameters.</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="state">A user provided object that distinguished this send from other
        /// send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(SearchQuery searchQuery, sys.AsyncCallback callback, object state = null)
        {
            var task = this.SearchAsync(searchQuery);

            return enc.Util.ToApm(task, callback, state);
        }

        /// <summary>
        /// <para>Searches for files and folders.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search.</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The mode</param>
        /// <returns>The task that represents the asynchronous send operation. The TResult
        /// parameter contains the response from the server.</returns>
        /// <exception cref="Dropbox.Api.ApiException{SearchError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public t.Task<SearchResults> SearchAsync(string path,
                                                 string query,
                                                 ulong start = 0,
                                                 ulong maxResults = 100,
                                                 SearchMode mode = null)
        {
            var searchQuery = new SearchQuery(path,
                                              query,
                                              start,
                                              maxResults,
                                              mode);

            return this.SearchAsync(searchQuery);
        }

        /// <summary>
        /// <para>Begins an asynchronous send to the search route.</para>
        /// </summary>
        /// <param name="path">The path in the user's Dropbox to search.</param>
        /// <param name="query">The string to search for. The search string is split on spaces
        /// into multiple tokens. For file name searching, the last token is used for prefix
        /// matching (i.e. "bat c" matches "bat cave" but not "batman car").</param>
        /// <param name="start">The starting index within the search results (used for
        /// paging).</param>
        /// <param name="maxResults">The maximum number of search results to return.</param>
        /// <param name="mode">The mode</param>
        /// <param name="callback">The method to be called when the asynchronous send is
        /// completed.</param>
        /// <param name="callbackState">A user provided object that distinguished this send
        /// from other send requests.</param>
        /// <returns>An object that represents the asynchronous send request.</returns>
        public sys.IAsyncResult BeginSearch(string path,
                                            string query,
                                            ulong start = 0,
                                            ulong maxResults = 100,
                                            SearchMode mode = null,
                                            sys.AsyncCallback callback = null,
                                            object callbackState = null)
        {
            var searchQuery = new SearchQuery(path,
                                              query,
                                              start,
                                              maxResults,
                                              mode);

            return this.BeginSearch(searchQuery, callback, callbackState);
        }

        /// <summary>
        /// <para>Waits for the pending asynchronous send to the search route to
        /// complete</para>
        /// </summary>
        /// <param name="asyncResult">The reference to the pending asynchronous send
        /// request</param>
        /// <returns>The response to the send request</returns>
        /// <exception cref="Dropbox.Api.ApiException{SearchError}">Thrown if there is an error
        /// processing the request; This will contain a <see cref="SearchError"/>.</exception>
        public SearchResults EndSearch(sys.IAsyncResult asyncResult)
        {
            var task = asyncResult as t.Task<SearchResults>;
            if (task == null)
            {
                throw new sys.InvalidOperationException();
            }

            return task.Result;
        }
    }
}
